// Generated by Copilot
import { useState, useEffect, useRef } from 'react';
import { Button } from '@/components/ui/button';
import { Copy, Check } from 'lucide-react';
import Prism from 'prismjs';
import 'prismjs/components/prism-json';
import { normalizeBasePath } from '@/lib/utils';

interface SchemaCodeViewerProps {
  schema: any;
  allSchemas: any[];
  showResolveToggle?: boolean;
}

/**
 * Helper function to resolve $ref in schema
 * This creates a resolved version of the schema by inlining both internal and external references
 * @param schema - The schema to resolve
 * @param allSchemas - All available schemas for resolving external references
 */
const resolveSchema = (schema: any, allSchemas: any[]): any => {
  const resolved = JSON.parse(JSON.stringify(schema)); // Deep clone

  // Create a lookup map for faster schema lookups
  const schemaMap = new Map<string, any>();
  allSchemas.forEach((s) => {
    schemaMap.set(s.id, s.rawContent);
  });

  // Helper to resolve both internal and external references
  const resolveRefs = (obj: any, root: any, depth: number = 0): any => {
    // Prevent infinite recursion
    if (depth > 10) {
      console.warn('Max recursion depth reached while resolving schema references');
      return obj;
    }

    if (typeof obj !== 'object' || obj === null) return obj;

    if (obj.$ref && typeof obj.$ref === 'string') {
      const ref = obj.$ref;

      // Handle internal references (#/definitions/...)
      if (ref.startsWith('#/')) {
        const path = ref.substring(2).split('/');
        let resolved = root;
        for (const key of path) {
          resolved = resolved?.[key];
          if (!resolved) {
            console.warn('Failed to resolve internal ref:', ref);
            return obj;
          }
        }
        // Recursively resolve the found reference
        return resolveRefs(resolved, root, depth + 1);
      }

      // Handle external references (https://mapcolonies.com/...)
      if (ref.startsWith('https://mapcolonies.com/')) {
        // Don't remove the prefix - the schema IDs in the map include the full URL
        const externalSchema = schemaMap.get(ref);
        if (externalSchema) {
          // Recursively resolve the external schema
          return resolveRefs(externalSchema, externalSchema, depth + 1);
        } else {
          console.warn('Failed to resolve external ref:', ref, 'Available schemas:', Array.from(schemaMap.keys()));
          return obj;
        }
      }

      // If $ref doesn't match known patterns, return as-is
      return obj;
    }

    // Recursively resolve nested objects/arrays
    if (Array.isArray(obj)) {
      return obj.map((item) => resolveRefs(item, root, depth));
    }

    const result: any = {};
    for (const [key, value] of Object.entries(obj)) {
      result[key] = resolveRefs(value, root, depth);
    }
    return result;
  };

  return resolveRefs(resolved, resolved);
};

/**
 * Post-process Prism highlighted HTML to inject clickable links for external schema references
 * Looks for "$ref" properties followed by mapcolonies.com URLs and makes them clickable
 * @param highlightedHtml - The Prism highlighted HTML
 * @param base - The base URL for navigation
 */
const injectLinksIntoHighlightedCode = (highlightedHtml: string, base: string): string => {
  // Pattern matches: "$ref": "https://mapcolonies.com/..."
  // After Prism highlighting, this becomes spans with token classes
  // We need to find the URL string and wrap it in an anchor tag
  return highlightedHtml.replace(
    /(<span class="token string">)"(https:\/\/mapcolonies\.com\/[^"]+)"(<\/span>)/g,
    (match, openSpan, url, closeSpan) => {
      const path = url.replace('https://mapcolonies.com/', '');
      // Keep the span but add an anchor inside
      return `${openSpan}"<a href="${base}schema/${path}" class="schema-link" onclick="event.stopPropagation()">${url}</a>"${closeSpan}`;
    }
  );
};

export default function SchemaCodeViewer({ schema, allSchemas, showResolveToggle = false }: SchemaCodeViewerProps) {
  const [copied, setCopied] = useState(false);
  const [showResolved, setShowResolved] = useState(false);
  const [highlightedCode, setHighlightedCode] = useState('');
  const base = normalizeBasePath(import.meta.env.BASE_URL || '/');

  // Get the schema to display based on toggle
  const displaySchema = showResolved ? resolveSchema(schema, allSchemas) : schema;

  useEffect(() => {
    console.log('=== Schema Resolution Debug ===');
    console.log('showResolved:', showResolved);
    console.log('allSchemas count:', allSchemas.length);
    console.log(
      'Sample schema IDs:',
      allSchemas.slice(0, 3).map((s) => s.id)
    );

    // Convert schema to formatted JSON string
    const jsonString = JSON.stringify(displaySchema, null, 2);

    console.log('Schema has $ref?', jsonString.includes('$ref'));
    console.log('Schema has mapcolonies.com?', jsonString.includes('mapcolonies.com'));
    console.log('First 500 chars of schema:', jsonString.substring(0, 500));

    // Highlight with Prism first
    const highlighted = Prism.highlight(jsonString, Prism.languages.json, 'json');

    // Only inject links when showing original (unresolved) schema
    // In resolved view, the URLs are replaced with actual schema content
    const finalCode = showResolved ? highlighted : injectLinksIntoHighlightedCode(highlighted, base);

    setHighlightedCode(finalCode);
  }, [displaySchema, base, showResolved]);

  const handleCopy = async () => {
    await navigator.clipboard.writeText(JSON.stringify(displaySchema, null, 2));
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  return (
    <div className="space-y-3">
      <div className="flex items-center justify-between">
        <p className="text-sm text-muted-foreground">
          {showResolved
            ? 'Showing fully resolved schema with all references expanded (internal and external)'
            : 'Showing original schema with references'}
        </p>
        <div className="flex gap-2">
          {showResolveToggle && (
            <Button variant="outline" size="sm" onClick={() => setShowResolved(!showResolved)}>
              {showResolved ? 'Show Original' : 'Show Resolved'}
            </Button>
          )}
          <Button variant="outline" size="sm" onClick={handleCopy}>
            {copied ? <Check className="h-4 w-4" /> : <Copy className="h-4 w-4" />}
          </Button>
        </div>
      </div>

      <div className="border rounded-lg overflow-hidden bg-[#282c34]">
        <pre className="p-4 overflow-x-auto text-sm !m-0">
          <code className="language-json" dangerouslySetInnerHTML={{ __html: highlightedCode }} />
        </pre>
      </div>

      <style>{`
        .schema-link {
          color: #61afef;
          text-decoration: underline;
          text-decoration-style: dotted;
          text-underline-offset: 2px;
          cursor: pointer;
          transition: all 0.2s ease;
        }
        .schema-link:hover {
          color: #56b6c2;
          text-decoration-style: solid;
          text-decoration-thickness: 2px;
        }
        
        /* Prism One Dark theme colors */
        .token.property { color: #e06c75; }
        .token.string { color: #98c379; }
        .token.number { color: #d19a66; }
        .token.boolean { color: #56b6c2; }
        .token.null { color: #56b6c2; }
        .token.punctuation { color: #abb2bf; }
        .token.operator { color: #abb2bf; }
      `}</style>
    </div>
  );
}
