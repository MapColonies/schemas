// Generated by Copilot
import { useState, useEffect } from 'react';
import { Search, ChevronRight } from 'lucide-react';
import { Button } from './ui/button';
import { Dialog, DialogTrigger, DialogContent } from './ui/dialog';
import { Document } from 'flexsearch';
import { normalizeBasePath } from '@/lib/utils';

interface Schema {
  id: string;
  path: string;
  version: number;
  title: string;
  description: string;
  category: string;
  rawContent: any;
}

interface SearchableSchema {
  id: string;
  path: string;
  version: number;
  title: string;
  description: string;
  category: string;
  rawContent: any;
  searchableContent: string;
  [key: string]: any;
}

interface SearchResult extends Schema {
  matchPreview?: string;
  matchField?: string;
}

interface SearchBarProps {
  onSchemaSelect?: (schemaId: string) => void;
}

/**
 * Search bar component with full-text search using FlexSearch
 * Searches through schema titles, descriptions, hierarchical paths, and content
 */
export default function SearchBar({ onSchemaSelect }: SearchBarProps) {
  const [open, setOpen] = useState(false);
  const [query, setQuery] = useState('');
  const [schemas, setSchemas] = useState<SearchableSchema[]>([]);
  const [searchIndex, setSearchIndex] = useState<Document<SearchableSchema> | null>(null);
  const [searchResults, setSearchResults] = useState<SearchResult[]>([]);

  // Load schemas and build search index
  useEffect(() => {
    const loadSchemas = async () => {
      try {
        const base = normalizeBasePath(import.meta.env.BASE_URL || '/');
        const response = await fetch(`${base}data/schemas.json`);
        const data = await response.json();
        const schemasData = data.schemas || [];

        // Create searchable schemas with full data
        const searchableSchemas: SearchableSchema[] = schemasData.map((schema: Schema) => ({
          ...schema,
          searchableContent: generateSearchableContent(schema.rawContent),
        }));

        setSchemas(searchableSchemas);

        // Create FlexSearch index with multiple fields
        const index = new Document<SearchableSchema>({
          document: {
            id: 'id',
            index: ['title', 'description', 'path', 'searchableContent'],
            store: ['id', 'path', 'version', 'title', 'description', 'category', 'rawContent', 'searchableContent'],
          },
          tokenize: 'forward',
          resolution: 9,
        });

        // Index all schemas with searchable content
        searchableSchemas.forEach((schema) => {
          index.add(schema);
        });

        setSearchIndex(index);
      } catch (error) {
        console.error('Failed to load schemas:', error);
      }
    };

    loadSchemas();
  }, []);

  // Handle keyboard shortcut (Cmd/Ctrl + K)
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
        e.preventDefault();
        setOpen(true);
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, []);

  // Perform search when query changes
  useEffect(() => {
    const performSearch = async () => {
      if (!searchIndex || !query.trim()) {
        setSearchResults([]);
        return;
      }

      const results = await searchIndex.searchAsync(query, {
        limit: 20,
        enrich: true,
      });

      // Flatten results from all fields and extract match context
      const uniqueSchemas = new Map<string, SearchResult>();

      results.forEach((fieldResult: any) => {
        const field = fieldResult.field;

        fieldResult.result.forEach((item: any) => {
          if (!uniqueSchemas.has(item.id)) {
            // item.doc contains the stored fields including rawContent and searchableContent
            const storedSchema = item.doc;

            // Generate match preview based on which field matched
            const matchInfo = generateMatchPreview(storedSchema, query, field);

            uniqueSchemas.set(item.id, {
              id: storedSchema.id,
              path: storedSchema.path,
              version: storedSchema.version,
              title: storedSchema.title,
              description: storedSchema.description,
              category: storedSchema.category,
              rawContent: storedSchema.rawContent,
              matchPreview: matchInfo.preview,
              matchField: matchInfo.field,
            });
          }
        });
      });

      setSearchResults(Array.from(uniqueSchemas.values()));
    };

    performSearch();
  }, [query, searchIndex]);

  const handleSchemaClick = (schema: Schema) => {
    const base = normalizeBasePath(import.meta.env.BASE_URL || '/');
    const path = `${schema.path}/v${schema.version}`;

    // If on graph page and callback provided, focus the node
    if (onSchemaSelect && window.location.pathname.includes('/graph')) {
      onSchemaSelect(schema.id);
      setOpen(false);
    } else {
      // Otherwise navigate to schema page
      window.location.href = `${base}schema/${path}`;
    }
  };

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        <Button variant="outline" className="justify-start text-sm text-muted-foreground min-w-[240px] max-w-[320px] h-10">
          <Search className="mr-2 h-4 w-4 flex-shrink-0" />
          <span className="truncate">Search schemas...</span>
          <kbd className="pointer-events-none ml-auto hidden h-5 select-none items-center gap-1 rounded border bg-muted px-1.5 font-mono text-[10px] font-medium opacity-100 sm:flex flex-shrink-0">
            <span className="text-xs">âŒ˜</span>K
          </kbd>
        </Button>
      </DialogTrigger>

      <DialogContent className="p-0 max-h-[80vh] flex flex-col">
        {/* Search Input */}
        <div className="flex items-center border-b px-4 py-3">
          <Search className="mr-2 h-5 w-5 text-muted-foreground flex-shrink-0" />
          <input
            type="text"
            placeholder="Search by title, description, path, or content..."
            value={query}
            onChange={(e) => setQuery(e.target.value)}
            className="flex-1 bg-transparent outline-none text-sm placeholder:text-muted-foreground"
            autoFocus
          />
          {query && (
            <button onClick={() => setQuery('')} className="ml-2 text-muted-foreground hover:text-foreground text-xs px-2 py-1 rounded border">
              Clear
            </button>
          )}
        </div>

        {/* Results */}
        <div className="overflow-y-auto flex-1 p-2">
          {!query ? (
            <div className="p-8 text-center text-muted-foreground text-sm">
              <Search className="h-12 w-12 mx-auto mb-3 opacity-20" />
              <p className="font-medium mb-1">Search for schemas</p>
              <p className="text-xs">Try searching by title, description, hierarchy, or schema content</p>
            </div>
          ) : searchResults.length === 0 ? (
            <div className="p-8 text-center text-muted-foreground text-sm">
              <p className="font-medium mb-1">No results found</p>
              <p className="text-xs">Try a different search term</p>
            </div>
          ) : (
            <div className="space-y-1">
              {searchResults.map((schema) => (
                <button
                  key={schema.id}
                  onClick={() => handleSchemaClick(schema)}
                  className="w-full text-left px-3 py-3 rounded-md hover:bg-accent transition-colors group"
                >
                  <div className="flex items-start justify-between gap-2">
                    <div className="flex-1 min-w-0">
                      <div className="flex items-center gap-2 mb-1">
                        <span className="font-medium text-sm truncate">{schema.title}</span>
                        <span
                          className="text-xs px-2 py-0.5 rounded-full capitalize flex-shrink-0"
                          style={{
                            backgroundColor: schema.category === 'common' ? '#3b82f620' : schema.category === 'infra' ? '#10b98120' : '#f59e0b20',
                            color: schema.category === 'common' ? '#3b82f6' : schema.category === 'infra' ? '#10b981' : '#f59e0b',
                          }}
                        >
                          {schema.category}
                        </span>
                      </div>
                      <p className="text-xs text-muted-foreground mb-1 line-clamp-2">{schema.description}</p>

                      {/* Match preview showing where the search term was found */}
                      {schema.matchPreview && (
                        <div className="mb-1 text-xs bg-muted/50 rounded px-2 py-1 font-mono">
                          <span className="text-muted-foreground/70 mr-1">{schema.matchField}:</span>
                          <span className="text-foreground" dangerouslySetInnerHTML={{ __html: schema.matchPreview }} />
                        </div>
                      )}

                      <p className="text-xs text-muted-foreground/70 font-mono">
                        {schema.path}/v{schema.version}
                      </p>
                    </div>
                    <ChevronRight className="h-4 w-4 text-muted-foreground opacity-0 group-hover:opacity-100 transition-opacity flex-shrink-0 mt-1" />
                  </div>
                </button>
              ))}
            </div>
          )}
        </div>

        {/* Footer */}
        <div className="border-t px-4 py-2 text-xs text-muted-foreground flex items-center justify-between">
          <span>{query && searchResults.length > 0 && `${searchResults.length} result${searchResults.length === 1 ? '' : 's'}`}</span>
          <div className="flex items-center gap-2">
            <kbd className="px-2 py-1 rounded border bg-muted">Esc</kbd>
            <span>Close</span>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}

/**
 * Generate searchable content from schema object
 * Recursively extracts all string values from the schema
 */
function generateSearchableContent(obj: any, depth = 0, maxDepth = 5): string {
  if (depth > maxDepth || !obj || typeof obj !== 'object') {
    return '';
  }

  const values: string[] = [];

  for (const key in obj) {
    const value = obj[key];

    // Add property names as searchable content
    values.push(key);

    if (typeof value === 'string') {
      values.push(value);
    } else if (typeof value === 'object' && value !== null) {
      values.push(generateSearchableContent(value, depth + 1, maxDepth));
    }
  }

  return values.filter(Boolean).join(' ');
}

/**
 * Generate a preview snippet showing where the query matched
 * Highlights the matching text and shows surrounding context
 */
function generateMatchPreview(schema: SearchableSchema, query: string, field: string): { preview: string; field: string } {
  const queryLower = query.toLowerCase();
  const maxPreviewLength = 100;
  const contextChars = 40;

  // Check title match
  if (field === 'title' && schema.title.toLowerCase().includes(queryLower)) {
    return {
      preview: highlightMatch(schema.title, query),
      field: 'title',
    };
  }

  // Check description match
  if (field === 'description' && schema.description.toLowerCase().includes(queryLower)) {
    return {
      preview: truncateWithContext(schema.description, query, maxPreviewLength, contextChars),
      field: 'description',
    };
  }

  // Check path match
  if (field === 'path' && schema.path.toLowerCase().includes(queryLower)) {
    return {
      preview: highlightMatch(schema.path, query),
      field: 'path',
    };
  }

  // Check in searchable content (schema properties)
  if (field === 'searchableContent' && schema.searchableContent.toLowerCase().includes(queryLower)) {
    // Try to find the match in the raw content for better context
    const match = findMatchInObject(schema.rawContent, query);
    if (match) {
      return {
        preview: truncateWithContext(match.value, query, maxPreviewLength, contextChars),
        field: match.path || 'content',
      };
    }
  }

  // Fallback
  return {
    preview: highlightMatch(schema.title, query),
    field: field || 'title',
  };
}

/**
 * Highlight matching text in a string
 */
function highlightMatch(text: string, query: string): string {
  const queryLower = query.toLowerCase();
  const textLower = text.toLowerCase();
  const index = textLower.indexOf(queryLower);

  if (index === -1) return escapeHtml(text);

  const before = text.slice(0, index);
  const match = text.slice(index, index + query.length);
  const after = text.slice(index + query.length);

  return `${escapeHtml(before)}<mark class="bg-yellow-200 dark:bg-yellow-800 text-foreground px-0.5 rounded">${escapeHtml(match)}</mark>${escapeHtml(after)}`;
}

/**
 * Truncate text with context around the match
 */
function truncateWithContext(text: string, query: string, maxLength: number, contextChars: number): string {
  const queryLower = query.toLowerCase();
  const textLower = text.toLowerCase();
  const index = textLower.indexOf(queryLower);

  if (index === -1) {
    // No match found, return truncated text
    return escapeHtml(text.slice(0, maxLength)) + (text.length > maxLength ? '...' : '');
  }

  // Calculate start and end positions with context
  const start = Math.max(0, index - contextChars);
  const end = Math.min(text.length, index + query.length + contextChars);

  const snippet = text.slice(start, end);
  const prefix = start > 0 ? '...' : '';
  const suffix = end < text.length ? '...' : '';

  // Highlight the match in the snippet
  const snippetLower = snippet.toLowerCase();
  const snippetIndex = snippetLower.indexOf(queryLower);

  if (snippetIndex === -1) {
    return prefix + escapeHtml(snippet) + suffix;
  }

  const before = snippet.slice(0, snippetIndex);
  const match = snippet.slice(snippetIndex, snippetIndex + query.length);
  const after = snippet.slice(snippetIndex + query.length);

  return `${prefix}${escapeHtml(before)}<mark class="bg-yellow-200 dark:bg-yellow-800 text-foreground px-0.5 rounded">${escapeHtml(match)}</mark>${escapeHtml(after)}${suffix}`;
}

/**
 * Find a match in a nested object and return the value with path
 */
function findMatchInObject(obj: any, query: string, path = '', depth = 0, maxDepth = 10): { value: string; path: string } | null {
  if (depth > maxDepth || !obj || typeof obj !== 'object') {
    return null;
  }

  const queryLower = query.toLowerCase();

  for (const key in obj) {
    const value = obj[key];
    const currentPath = path ? `${path}.${key}` : key;

    // Check if the key itself matches
    if (key.toLowerCase().includes(queryLower)) {
      return { value: `${key}: ${JSON.stringify(value)}`.slice(0, 200), path: currentPath };
    }

    // Check string values
    if (typeof value === 'string' && value.toLowerCase().includes(queryLower)) {
      return { value, path: currentPath };
    }

    // Check nested objects
    if (typeof value === 'object' && value !== null) {
      const nestedMatch = findMatchInObject(value, query, currentPath, depth + 1, maxDepth);
      if (nestedMatch) {
        return nestedMatch;
      }
    }
  }

  return null;
}

/**
 * Escape HTML to prevent XSS
 */
function escapeHtml(text: string): string {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}
