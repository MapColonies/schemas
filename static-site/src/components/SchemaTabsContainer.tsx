// Generated by Copilot
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import CodeViewer from '@/components/CodeViewer';
import SchemaCodeViewer from '@/components/SchemaCodeViewer';
import ForceGraph from '@/components/ForceGraph';
import { normalizeBasePath } from '@/lib/utils';

interface SchemaTabsContainerProps {
  schema: any;
  graphData: any;
  configs: any;
  allSchemas: any[];
}

/**
 * Represents an environment variable found in a schema
 */
interface EnvironmentVariable {
  envName: string;
  propertyPath: string;
  type: string;
  required: boolean;
  description?: string;
  format?: string;
  default?: any;
  refLink?: string; // External reference link if this env var comes from a referenced schema
}

/**
 * Recursively extract environment variables from schema properties
 * @param schema - The schema or sub-schema to extract from
 * @param pathPrefix - The current property path (e.g., "auth.username")
 * @param requiredFields - Set of required field names at current level
 * @param schemaMap - Map of all schemas for resolving external references
 * @param rootSchema - The root schema for resolving internal references
 * @param visitedRefs - Set of visited references to prevent infinite loops
 */
const extractEnvVars = (
  schema: any,
  pathPrefix: string = '',
  requiredFields: Set<string> = new Set(),
  schemaMap?: Map<string, any>,
  rootSchema?: any,
  visitedRefs: Set<string> = new Set()
): EnvironmentVariable[] => {
  const envVars: EnvironmentVariable[] = [];

  if (!schema || typeof schema !== 'object') {
    return envVars;
  }

  // Handle $ref - resolve and extract from referenced schema
  if (schema.$ref && typeof schema.$ref === 'string') {
    // Prevent infinite loops
    if (visitedRefs.has(schema.$ref)) {
      return envVars;
    }
    visitedRefs.add(schema.$ref);

    let resolvedSchema: any = null;
    let refLink: string | undefined = undefined;

    // Resolve internal references (starting with #/)
    if (schema.$ref.startsWith('#/')) {
      const path = schema.$ref.substring(2).split('/');
      resolvedSchema = rootSchema || schema;
      for (const segment of path) {
        resolvedSchema = resolvedSchema?.[segment];
      }
    }
    // Resolve external references (https://mapcolonies.com/...)
    else if (schema.$ref.startsWith('https://mapcolonies.com/')) {
      resolvedSchema = schemaMap?.get(schema.$ref);
      refLink = schema.$ref; // Store the external reference for linking
    }

    if (resolvedSchema) {
      // Extract env vars from the referenced schema
      const refEnvVars = extractEnvVars(resolvedSchema, pathPrefix, requiredFields, schemaMap, rootSchema, visitedRefs);

      // If this was an external ref, add the reference link to each env var
      if (refLink) {
        refEnvVars.forEach((envVar) => {
          envVar.refLink = refLink;
        });
      }

      envVars.push(...refEnvVars);
    }

    // Continue processing the schema in case there are more properties
  }

  // Check if current schema has x-env-value
  if (schema['x-env-value']) {
    const propertyName = pathPrefix.split('.').pop() || pathPrefix;
    envVars.push({
      envName: schema['x-env-value'],
      propertyPath: pathPrefix,
      type: schema.type || 'unknown',
      required: requiredFields.has(propertyName),
      description: schema.description,
      format: schema['x-env-format'],
      default: schema.default,
    });
  }

  // Recursively process properties
  if (schema.properties) {
    const required = new Set<string>(schema.required || []);
    Object.entries(schema.properties).forEach(([key, prop]: [string, any]) => {
      const newPath = pathPrefix ? `${pathPrefix}.${key}` : key;
      envVars.push(...extractEnvVars(prop, newPath, required, schemaMap, rootSchema, visitedRefs));
    });
  }

  // Handle arrays with items
  if (schema.items) {
    envVars.push(...extractEnvVars(schema.items, pathPrefix, requiredFields, schemaMap, rootSchema, visitedRefs));
  }

  // Handle allOf, anyOf, oneOf
  ['allOf', 'anyOf', 'oneOf'].forEach((combiner) => {
    if (Array.isArray(schema[combiner])) {
      schema[combiner].forEach((subSchema: any) => {
        envVars.push(...extractEnvVars(subSchema, pathPrefix, requiredFields, schemaMap, rootSchema, visitedRefs));
      });
    }
  });

  return envVars;
};

/**
 * Extract all environment variables from a schema
 * @param schema - The complete schema object
 * @param allSchemas - All available schemas for resolving external references
 */
const extractEnvironmentVariables = (schema: any, allSchemas: any[]): EnvironmentVariable[] => {
  // Create a lookup map for faster schema lookups
  const schemaMap = new Map<string, any>();
  allSchemas.forEach((s) => {
    schemaMap.set(s.id, s.rawContent);
  });

  return extractEnvVars(schema, '', new Set(), schemaMap, schema, new Set());
};

/**
 * Component to display environment variables in a table
 */
const EnvironmentVariablesViewer = ({ envVars }: { envVars: EnvironmentVariable[] }) => {
  const base = normalizeBasePath(import.meta.env.BASE_URL || '/');

  const getRefLink = (ref: string): string => {
    if (ref.startsWith('https://mapcolonies.com/')) {
      return ref.replace('https://mapcolonies.com/', '');
    }
    return ref;
  };

  if (envVars.length === 0) {
    return <div className="p-4 text-muted-foreground">No environment variables defined in this schema.</div>;
  }

  return (
    <div className="overflow-auto">
      <table className="w-full border-collapse">
        <thead>
          <tr className="border-b bg-muted/50">
            <th className="p-3 text-left font-semibold">Environment Variable</th>
            <th className="p-3 text-left font-semibold">Property Path</th>
            <th className="p-3 text-left font-semibold">Type</th>
            <th className="p-3 text-left font-semibold">Required</th>
            <th className="p-3 text-left font-semibold">Format</th>
            <th className="p-3 text-left font-semibold">Default</th>
            <th className="p-3 text-left font-semibold">Description</th>
            <th className="p-3 text-left font-semibold">Reference</th>
          </tr>
        </thead>
        <tbody>
          {envVars.map((envVar, index) => (
            <tr key={index} className="border-b hover:bg-muted/30">
              <td className="p-3 font-mono text-sm">{envVar.envName}</td>
              <td className="p-3 font-mono text-sm text-muted-foreground">{envVar.propertyPath}</td>
              <td className="p-3">
                <span className="rounded bg-primary/10 px-2 py-1 text-xs font-medium">{envVar.type}</span>
              </td>
              <td className="p-3">
                {envVar.required ? <span className="text-red-600 dark:text-red-400">Yes</span> : <span className="text-muted-foreground">No</span>}
              </td>
              <td className="p-3">
                {envVar.format && (
                  <span className="rounded bg-blue-100 dark:bg-blue-900/30 px-2 py-1 text-xs font-medium text-blue-700 dark:text-blue-300">
                    {envVar.format}
                  </span>
                )}
              </td>
              <td className="p-3 font-mono text-sm">{envVar.default !== undefined ? JSON.stringify(envVar.default) : '-'}</td>
              <td className="p-3 text-sm">{envVar.description || '-'}</td>
              <td className="p-3">
                {envVar.refLink ? (
                  <a
                    href={`${base}schema/${getRefLink(envVar.refLink)}`}
                    className="text-blue-600 hover:underline text-xs flex items-center gap-1"
                    title={`Defined in ${envVar.refLink}`}
                  >
                    ðŸ”— {envVar.refLink.split('/').slice(-2).join('/')}
                  </a>
                ) : (
                  <span className="text-muted-foreground text-xs">Local</span>
                )}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

/**
 * Helper function to resolve $ref in schema
 * This creates a resolved version of the schema by inlining both internal and external references
 * @param schema - The schema to resolve
 * @param allSchemas - All available schemas for resolving external references
 */
const resolveSchema = (schema: any, allSchemas: any[]): any => {
  const resolved = JSON.parse(JSON.stringify(schema)); // Deep clone

  // Create a lookup map for faster schema lookups
  const schemaMap = new Map<string, any>();
  allSchemas.forEach((s) => {
    schemaMap.set(s.id, s.rawContent);
  });

  // Helper to resolve both internal and external references
  const resolveRefs = (obj: any, root: any, depth: number = 0): any => {
    // Prevent infinite recursion
    if (depth > 10) {
      console.warn('Max recursion depth reached while resolving schema references');
      return obj;
    }

    if (typeof obj !== 'object' || obj === null) return obj;

    if (obj.$ref && typeof obj.$ref === 'string') {
      // Resolve internal references (starting with #/)
      if (obj.$ref.startsWith('#/')) {
        const path = obj.$ref.substring(2).split('/');
        let resolved = root;
        for (const segment of path) {
          resolved = resolved?.[segment];
        }
        if (resolved) {
          // Return the resolved content inline (replacing the $ref)
          return resolveRefs(resolved, root, depth + 1);
        }
      }
      // Resolve external references (https://mapcolonies.com/...)
      else if (obj.$ref.startsWith('https://mapcolonies.com/')) {
        const externalSchema = schemaMap.get(obj.$ref);
        if (externalSchema) {
          // Return the external schema inline, resolving its references too
          return resolveRefs(externalSchema, externalSchema, depth + 1);
        } else {
          // Keep the reference if schema not found
          console.warn(`External schema not found: ${obj.$ref}`);
          return obj;
        }
      }
      // Keep other references as-is
      return obj;
    }

    // Recursively resolve nested objects and arrays
    if (Array.isArray(obj)) {
      return obj.map((item) => resolveRefs(item, root, depth));
    }

    const result: any = {};
    for (const key in obj) {
      result[key] = resolveRefs(obj[key], root, depth);
    }
    return result;
  };

  return resolveRefs(resolved, schema);
};

/**
 * Extract only the type definition from TypeScript content
 * Shows only the content inside "readonly [typeSymbol]: { ... }"
 */
const extractExportedType = (typeContent: string): string => {
  // Find the start of "readonly [typeSymbol]: {"
  const typeSymbolStart = typeContent.indexOf('readonly [typeSymbol]: {');
  if (typeSymbolStart === -1) {
    // Fallback: try to find just "declare const exported:"
    const exportedStart = typeContent.indexOf('declare const exported:');
    if (exportedStart === -1) {
      return typeContent;
    }
    const exportTypeIndex = typeContent.indexOf('export type schemaType', exportedStart);
    return exportTypeIndex === -1 ? typeContent.substring(exportedStart).trim() : typeContent.substring(exportedStart, exportTypeIndex).trim();
  }

  // Start after the opening brace of [typeSymbol]: {
  const contentStart = typeContent.indexOf('{', typeSymbolStart + 'readonly [typeSymbol]: '.length);
  if (contentStart === -1) {
    return typeContent;
  }

  // Find the matching closing brace for [typeSymbol]
  // We need to count braces to find the correct closing brace
  let braceCount = 1;
  let pos = contentStart + 1;

  while (pos < typeContent.length && braceCount > 0) {
    if (typeContent[pos] === '{') {
      braceCount++;
    } else if (typeContent[pos] === '}') {
      braceCount--;
    }
    pos++;
  }

  if (braceCount === 0) {
    // Extract the content between the braces (including the braces)
    let extracted = typeContent.substring(contentStart, pos).trim();

    // Remove one level of indentation (4 spaces) from all lines
    const lines = extracted.split('\n');
    const dedentedLines = lines.map((line) => {
      // Count leading spaces
      const match = line.match(/^(\s*)/);
      const leadingSpaces = match ? match[0].length : 0;

      // Remove 4 spaces if there are at least 4 leading spaces
      if (leadingSpaces >= 4) {
        return line.substring(4);
      }
      return line;
    });

    return dedentedLines.join('\n');
  }

  return typeContent;
};

/**
 * Container component for schema tabs with all React components
 * This ensures proper client-side hydration for all interactive elements
 */
export default function SchemaTabsContainer({ schema, graphData, configs, allSchemas }: SchemaTabsContainerProps) {
  // Extract environment variables from schema
  const envVars = extractEnvironmentVariables(schema.rawContent, allSchemas);
  const hasEnvVars = envVars.length > 0;

  return (
    <Tabs defaultValue="raw">
      <TabsList>
        <TabsTrigger value="raw">Raw Schema</TabsTrigger>
        <TabsTrigger value="typescript">TypeScript</TabsTrigger>
        <TabsTrigger value="docs">Documentation</TabsTrigger>
        {hasEnvVars && <TabsTrigger value="env">Environment Variables</TabsTrigger>}
        <TabsTrigger value="dependencies">Dependencies</TabsTrigger>
        <TabsTrigger value="graph">Dependencies Graph</TabsTrigger>
        {configs && <TabsTrigger value="configs">Configs</TabsTrigger>}
      </TabsList>

      <TabsContent value="raw">
        <div className="space-y-3">
          <SchemaCodeViewer schema={schema.rawContent} allSchemas={allSchemas} showResolveToggle={true} />
        </div>
      </TabsContent>

      <TabsContent value="typescript">
        {schema.typeContent ? (
          <CodeViewer code={extractExportedType(schema.typeContent)} language="typescript" />
        ) : (
          <div className="border rounded-lg p-8 text-center text-muted-foreground">TypeScript definitions not available for this schema.</div>
        )}
      </TabsContent>

      <TabsContent value="docs">
        <div className="border rounded-lg p-6">
          <SchemaDocumentation schema={schema.rawContent} allSchemas={allSchemas} />
        </div>
      </TabsContent>

      {hasEnvVars && (
        <TabsContent value="env">
          <div className="border rounded-lg">
            <EnvironmentVariablesViewer envVars={envVars} />
          </div>
        </TabsContent>
      )}

      <TabsContent value="dependencies">
        <div className="border rounded-lg p-6">
          <SchemaDependencies schema={schema} allSchemas={allSchemas} />
        </div>
      </TabsContent>

      <TabsContent value="graph">
        <div className="border rounded-lg" style={{ height: '600px' }}>
          <ForceGraph data={graphData} focusNodeId={schema.id} />
        </div>
      </TabsContent>

      {configs && (
        <TabsContent value="configs">
          <div className="space-y-4">
            <p className="text-sm text-muted-foreground mb-4">Default configuration instances for this schema</p>
            {configs.instances.map((config: any, idx: number) => (
              <div key={idx} className="border rounded-lg p-4">
                <h3 className="font-semibold mb-3">{config.name}</h3>
                <CodeViewer code={JSON.stringify(config.value, null, 2)} language="json" />
              </div>
            ))}
          </div>
        </TabsContent>
      )}
    </Tabs>
  );
}

/**
 * Schema documentation component (React version)
 */
function SchemaDocumentation({ schema, allSchemas }: { schema: any; allSchemas: any[] }) {
  const base = normalizeBasePath(import.meta.env.BASE_URL || '/');

  // Create a lookup map for resolving external references
  const schemaMap = new Map<string, any>();
  allSchemas.forEach((s) => {
    schemaMap.set(s.id, s.rawContent);
  });

  // Helper to resolve $ref and get the actual schema object
  const resolveRef = (ref: string): any => {
    if (ref.startsWith('#/')) {
      // Internal reference
      const path = ref.substring(2).split('/');
      let resolved = schema;
      for (const key of path) {
        resolved = resolved?.[key];
        if (!resolved) return null;
      }
      return resolved;
    } else if (ref.startsWith('https://mapcolonies.com/')) {
      // External reference
      const externalSchema = schemaMap.get(ref);
      return externalSchema || null;
    }
    return null;
  };

  // Helper function to extract properties from schema (handling allOf and $ref)
  const extractProperties = (schemaObj: any): { properties: any; required: string[] } => {
    let allProperties: any = {};
    let allRequired: string[] = [];

    // Handle $ref at the top level
    if (schemaObj.$ref) {
      const resolved = resolveRef(schemaObj.$ref);
      if (resolved) {
        return extractProperties(resolved);
      }
    }

    if (schemaObj.properties) {
      allProperties = { ...allProperties, ...schemaObj.properties };
    }
    if (schemaObj.required) {
      allRequired = [...allRequired, ...schemaObj.required];
    }

    if (schemaObj.allOf) {
      schemaObj.allOf.forEach((subSchema: any) => {
        // Resolve $ref in allOf items
        let resolvedSubSchema = subSchema;
        if (subSchema.$ref) {
          resolvedSubSchema = resolveRef(subSchema.$ref);
        }

        if (resolvedSubSchema) {
          const extracted = extractProperties(resolvedSubSchema);
          allProperties = { ...allProperties, ...extracted.properties };
          allRequired = [...allRequired, ...extracted.required];
        }
      });
    }

    return { properties: allProperties, required: allRequired };
  };

  const { properties, required } = extractProperties(schema);
  const definitions = schema.definitions || {};

  // Generated by Copilot
  // Track nested object properties that need their own sections
  const nestedObjects: Array<{ path: string; schema: any; parentPath: string; ref?: string }> = [];

  const formatType = (prop: any): string => {
    if (prop.type) {
      return Array.isArray(prop.type) ? prop.type.join(' | ') : prop.type;
    }
    if (prop.enum) return 'enum';
    if (prop.oneOf || prop.anyOf) return 'union';
    return 'object';
  };

  const getRefLink = (ref: string): string => {
    if (ref.startsWith('https://mapcolonies.com/')) {
      return ref.replace('https://mapcolonies.com/', '');
    }
    return ref;
  };

  // Generated by Copilot
  // Recursively collect nested object properties
  const collectNestedObjects = (props: any, parentPath: string = '') => {
    Object.entries(props).forEach(([name, prop]: [string, any]) => {
      let resolvedProp = prop;
      const originalRef = prop.$ref; // Store the original $ref before resolving

      if (prop.$ref) {
        const resolved = resolveRef(prop.$ref);
        if (resolved) {
          resolvedProp = { ...resolved, ...prop };
        }
      }

      const currentPath = parentPath ? `${parentPath}.${name}` : name;

      if (resolvedProp.properties && Object.keys(resolvedProp.properties).length > 0) {
        nestedObjects.push({
          path: currentPath,
          schema: resolvedProp,
          parentPath: parentPath,
          ref: originalRef, // Store the ref if this came from a $ref
        });
        // Recursively collect deeper nested objects
        collectNestedObjects(resolvedProp.properties, currentPath);
      }
    });
  };

  // Collect all nested objects
  collectNestedObjects(properties);

  return (
    <div className="space-y-6">
      {schema.description && <p className="text-muted-foreground border-l-4 border-blue-500 pl-4 py-2 my-4">{schema.description}</p>}

      {/* Main Properties Section */}
      {Object.keys(properties).length > 0 ? (
        <div>
          <h3 className="text-lg font-semibold mb-3">Properties</h3>
          <div className="border rounded-lg overflow-hidden">
            <table className="w-full">
              <thead className="bg-gray-100 dark:bg-gray-800">
                <tr>
                  <th className="px-4 py-2 text-left text-sm font-semibold">Property</th>
                  <th className="px-4 py-2 text-left text-sm font-semibold">Type</th>
                  <th className="px-4 py-2 text-left text-sm font-semibold">Required</th>
                  <th className="px-4 py-2 text-left text-sm font-semibold">Description</th>
                </tr>
              </thead>
              <tbody>
                {Object.entries(properties).map(([name, prop]: [string, any]) => {
                  // Generated by Copilot
                  // Resolve $ref in property to get nested properties
                  let resolvedProp = prop;
                  if (prop.$ref) {
                    const resolved = resolveRef(prop.$ref);
                    if (resolved) {
                      // Merge the resolved schema with the property
                      resolvedProp = { ...resolved, ...prop };
                    }
                  }

                  const hasNestedProps = resolvedProp.properties && Object.keys(resolvedProp.properties).length > 0;

                  return (
                    <tr key={name} className="border-t hover:bg-gray-50 dark:hover:bg-gray-800/50">
                      <td className="px-4 py-3 font-mono text-sm font-medium">{name}</td>
                      <td className="px-4 py-3">
                        {resolvedProp.type && (
                          <code className="bg-gray-100 dark:bg-gray-800 px-2 py-1 rounded text-xs">{formatType(resolvedProp)}</code>
                        )}
                        {prop.$ref &&
                          (prop.$ref.startsWith('https://') ? (
                            <a href={`${base}schema/${getRefLink(prop.$ref)}`} className="text-blue-600 hover:underline text-sm ml-2">
                              {prop.$ref.split('/').pop()}
                            </a>
                          ) : (
                            <a href={`#def-${prop.$ref.replace('#/definitions/', '')}`} className="text-blue-600 hover:underline text-sm ml-2">
                              {prop.$ref.split('/').pop()}
                            </a>
                          ))}
                        {!resolvedProp.type && !prop.$ref && (
                          <code className="bg-gray-100 dark:bg-gray-800 px-2 py-1 rounded text-xs">{formatType(resolvedProp)}</code>
                        )}
                        {hasNestedProps && (
                          <a href={`#prop-${name}`} className="text-blue-600 hover:underline text-xs ml-2">
                            â†’ see properties
                          </a>
                        )}
                      </td>
                      <td className="px-4 py-3 text-center">
                        {required.includes(name) ? (
                          <span className="text-green-600 font-semibold" title="Required">
                            âœ“
                          </span>
                        ) : (
                          <span className="text-gray-400" title="Optional">
                            -
                          </span>
                        )}
                      </td>
                      <td className="px-4 py-3 text-sm text-muted-foreground">
                        {resolvedProp.description || '-'}
                        {resolvedProp.default !== undefined && (
                          <div className="mt-1 text-xs">
                            <span className="font-medium">Default:</span>
                            <code className="bg-gray-100 dark:bg-gray-800 px-1 rounded ml-1">{JSON.stringify(resolvedProp.default)}</code>
                          </div>
                        )}
                        {resolvedProp.enum && (
                          <div className="mt-1 text-xs">
                            <span className="font-medium">Values:</span>
                            <code className="bg-gray-100 dark:bg-gray-800 px-1 rounded ml-1">{resolvedProp.enum.join(', ')}</code>
                          </div>
                        )}
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>
        </div>
      ) : (
        <div className="text-center py-8 text-muted-foreground border rounded-lg">
          No direct properties defined. This schema may use references or definitions.
        </div>
      )}

      {/* Generated by Copilot */}
      {/* Nested Object Properties Sections */}
      {nestedObjects.map(({ path, schema, parentPath, ref }) => {
        const anchorId = `prop-${path}`;
        const nestedRequired = schema.required || [];
        const isExternalRef = ref && ref.startsWith('https://');

        return (
          <div key={path} id={anchorId} className="scroll-mt-20">
            <h3 className="text-lg font-semibold mb-3 flex items-center gap-2 flex-wrap">
              <code className="text-sm bg-gray-100 dark:bg-gray-800 px-2 py-1 rounded">{path}</code>
              {isExternalRef && (
                <a
                  href={`${base}schema/${getRefLink(ref)}`}
                  className="text-xs text-blue-600 hover:underline bg-blue-50 dark:bg-blue-900/20 px-2 py-1 rounded"
                  title="View full schema definition"
                >
                  ðŸ”— {ref.split('/').slice(-2).join('/')}
                </a>
              )}
              {parentPath && (
                <a href={`#prop-${parentPath}`} className="text-xs text-blue-600 hover:underline">
                  â†‘ back to {parentPath}
                </a>
              )}
            </h3>
            {schema.description && <p className="text-sm text-muted-foreground mb-3 pl-4 border-l-2 border-gray-300">{schema.description}</p>}
            <div className="border rounded-lg overflow-hidden">
              <table className="w-full">
                <thead className="bg-gray-100 dark:bg-gray-800">
                  <tr>
                    <th className="px-4 py-2 text-left text-sm font-semibold">Property</th>
                    <th className="px-4 py-2 text-left text-sm font-semibold">Type</th>
                    <th className="px-4 py-2 text-left text-sm font-semibold">Required</th>
                    <th className="px-4 py-2 text-left text-sm font-semibold">Description</th>
                  </tr>
                </thead>
                <tbody>
                  {Object.entries(schema.properties).map(([name, prop]: [string, any]) => {
                    // Resolve $ref for nested properties
                    let resolvedProp = prop;
                    if (prop.$ref) {
                      const resolved = resolveRef(prop.$ref);
                      if (resolved) {
                        resolvedProp = { ...resolved, ...prop };
                      }
                    }

                    const hasNestedProps = resolvedProp.properties && Object.keys(resolvedProp.properties).length > 0;
                    const nestedPath = `${path}.${name}`;

                    return (
                      <tr key={name} className="border-t hover:bg-gray-50 dark:hover:bg-gray-800/50">
                        <td className="px-4 py-3 font-mono text-sm font-medium">{name}</td>
                        <td className="px-4 py-3">
                          {resolvedProp.type && (
                            <code className="bg-gray-100 dark:bg-gray-800 px-2 py-1 rounded text-xs">{formatType(resolvedProp)}</code>
                          )}
                          {prop.$ref &&
                            (prop.$ref.startsWith('https://') ? (
                              <a href={`${base}schema/${getRefLink(prop.$ref)}`} className="text-blue-600 hover:underline text-sm ml-2">
                                {prop.$ref.split('/').pop()}
                              </a>
                            ) : (
                              <a href={`#def-${prop.$ref.replace('#/definitions/', '')}`} className="text-blue-600 hover:underline text-sm ml-2">
                                {prop.$ref.split('/').pop()}
                              </a>
                            ))}
                          {!resolvedProp.type && !prop.$ref && (
                            <code className="bg-gray-100 dark:bg-gray-800 px-2 py-1 rounded text-xs">{formatType(resolvedProp)}</code>
                          )}
                          {hasNestedProps && (
                            <a href={`#prop-${nestedPath}`} className="text-blue-600 hover:underline text-xs ml-2">
                              â†’ see properties
                            </a>
                          )}
                        </td>
                        <td className="px-4 py-3 text-center">
                          {nestedRequired.includes(name) ? (
                            <span className="text-green-600 font-semibold" title="Required">
                              âœ“
                            </span>
                          ) : (
                            <span className="text-gray-400" title="Optional">
                              -
                            </span>
                          )}
                        </td>
                        <td className="px-4 py-3 text-sm text-muted-foreground">
                          {resolvedProp.description || '-'}
                          {resolvedProp.default !== undefined && (
                            <div className="mt-1 text-xs">
                              <span className="font-medium">Default:</span>
                              <code className="bg-gray-100 dark:bg-gray-800 px-1 rounded ml-1">{JSON.stringify(resolvedProp.default)}</code>
                            </div>
                          )}
                          {resolvedProp.enum && (
                            <div className="mt-1 text-xs">
                              <span className="font-medium">Values:</span>
                              <code className="bg-gray-100 dark:bg-gray-800 px-1 rounded ml-1">{resolvedProp.enum.join(', ')}</code>
                            </div>
                          )}
                        </td>
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            </div>
          </div>
        );
      })}

      {/* Definitions Section */}
      {Object.keys(definitions).length > 0 && (
        <div>
          <h3 className="text-lg font-semibold mb-3">Definitions</h3>
          <div className="space-y-4">
            {Object.entries(definitions).map(([defName, defSchema]: [string, any]) => {
              const defProps = defSchema.properties || {};
              const defRequired = defSchema.required || [];

              return (
                <div key={defName} id={`def-${defName}`} className="border rounded-lg p-4 scroll-mt-20">
                  <h4 className="font-semibold text-md mb-2 font-mono">{defName}</h4>
                  {defSchema.description && <p className="text-sm text-muted-foreground mb-3">{defSchema.description}</p>}
                  {Object.keys(defProps).length > 0 ? (
                    <div className="border rounded-lg overflow-hidden">
                      <table className="w-full text-sm">
                        <thead className="bg-gray-50 dark:bg-gray-800/50">
                          <tr>
                            <th className="px-3 py-2 text-left text-xs font-semibold">Property</th>
                            <th className="px-3 py-2 text-left text-xs font-semibold">Type</th>
                            <th className="px-3 py-2 text-left text-xs font-semibold">Required</th>
                            <th className="px-3 py-2 text-left text-xs font-semibold">Description</th>
                          </tr>
                        </thead>
                        <tbody>
                          {Object.entries(defProps).map(([propName, prop]: [string, any]) => (
                            <tr key={propName} className="border-t hover:bg-gray-50 dark:hover:bg-gray-800/50">
                              <td className="px-3 py-2 font-mono text-xs">{propName}</td>
                              <td className="px-3 py-2">
                                <code className="bg-gray-100 dark:bg-gray-800 px-1.5 py-0.5 rounded text-xs">{formatType(prop)}</code>
                              </td>
                              <td className="px-3 py-2 text-center">
                                {defRequired.includes(propName) ? (
                                  <span className="text-green-600 font-semibold">âœ“</span>
                                ) : (
                                  <span className="text-gray-400">-</span>
                                )}
                              </td>
                              <td className="px-3 py-2 text-xs text-muted-foreground">
                                {prop.description || '-'}
                                {prop.default !== undefined && (
                                  <div className="mt-0.5">
                                    <span className="font-medium">Default:</span>
                                    <code className="bg-gray-100 dark:bg-gray-800 px-1 rounded ml-1">{JSON.stringify(prop.default)}</code>
                                  </div>
                                )}
                              </td>
                            </tr>
                          ))}
                        </tbody>
                      </table>
                    </div>
                  ) : (
                    <p className="text-sm text-muted-foreground italic">No properties defined for this definition.</p>
                  )}
                </div>
              );
            })}
          </div>
        </div>
      )}
    </div>
  );
}

/**
 * Schema dependencies component showing uses and used-by relationships
 * Generated by Copilot
 */
function SchemaDependencies({ schema, allSchemas }: { schema: any; allSchemas: any[] }) {
  const base = normalizeBasePath(import.meta.env.BASE_URL || '/');

  const getRefLink = (ref: string): string => {
    if (ref.startsWith('https://mapcolonies.com/')) {
      return ref.replace('https://mapcolonies.com/', '');
    }
    return ref;
  };

  // Extract schemas that this schema references (uses)
  const usedSchemas = schema.references || [];

  // Extract schemas that reference this schema (used by)
  const usedBySchemas = schema.referencedBy || [];

  return (
    <div className="space-y-6">
      {/* Schemas Used by This Schema */}
      <div>
        <h3 className="text-lg font-semibold mb-3">Uses ({usedSchemas.length})</h3>
        {usedSchemas.length > 0 ? (
          <div className="border rounded-lg divide-y">
            {usedSchemas.map((ref: string, idx: number) => (
              <div key={idx} className="p-4 hover:bg-gray-50 dark:hover:bg-gray-800/50">
                <a href={`${base}schema/${getRefLink(ref)}`} className="text-blue-600 hover:underline font-mono text-sm">
                  {ref.replace('https://mapcolonies.com/', '')}
                </a>
              </div>
            ))}
          </div>
        ) : (
          <div className="border rounded-lg p-6 text-center text-muted-foreground">This schema does not reference any other schemas.</div>
        )}
      </div>

      {/* Schemas That Use This Schema */}
      <div>
        <h3 className="text-lg font-semibold mb-3">Used By ({usedBySchemas.length})</h3>
        {usedBySchemas.length > 0 ? (
          <div className="border rounded-lg divide-y">
            {usedBySchemas.map((ref: string, idx: number) => (
              <div key={idx} className="p-4 hover:bg-gray-50 dark:hover:bg-gray-800/50">
                <a href={`${base}schema/${getRefLink(ref)}`} className="text-blue-600 hover:underline font-mono text-sm">
                  {ref.replace('https://mapcolonies.com/', '')}
                </a>
              </div>
            ))}
          </div>
        ) : (
          <div className="border rounded-lg p-6 text-center text-muted-foreground">This schema is not referenced by any other schemas.</div>
        )}
      </div>
    </div>
  );
}
