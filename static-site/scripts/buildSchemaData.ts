// Generated by Copilot
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { glob } from 'glob';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

interface SchemaMetadata {
  id: string;
  path: string;
  version: number;
  title: string;
  description: string;
  category: string;
  rawContent: any;
  typeContent: string;
  references: string[];
  internalRefs: string[];
  hasConfig: boolean;
  referencedBy: string[];
}

interface SchemaData {
  schemas: SchemaMetadata[];
  categories: { name: string; count: number }[];
}

/**
 * Recursively extract all $ref properties from a JSON object
 * @param obj - The object to traverse
 * @param refs - Object to accumulate references
 */
const extractReferences = (obj: any, refs: { external: string[]; internal: string[] }): void => {
  if (typeof obj !== 'object' || obj === null) return;

  if (obj.$ref && typeof obj.$ref === 'string') {
    if (obj.$ref.startsWith('https://mapcolonies.com/')) {
      refs.external.push(obj.$ref);
    } else if (obj.$ref.startsWith('#/')) {
      refs.internal.push(obj.$ref);
    }
  }

  for (const key in obj) {
    extractReferences(obj[key], refs);
  }
};

/**
 * Main function to build schema data
 */
const buildSchemaData = async (): Promise<void> => {
  console.log('Building schema data...');

  const schemasDir = path.resolve(__dirname, '../../schemas');
  const buildDir = path.resolve(__dirname, '../../build/schemas');
  const outputDir = path.resolve(__dirname, '../public/data');

  // Ensure output directory exists
  fs.mkdirSync(outputDir, { recursive: true });

  // Find all schema files
  const schemaFiles = glob.sync('**/*.schema.json', { cwd: schemasDir });
  console.log(`Found ${schemaFiles.length} schema files`);

  const schemas: SchemaMetadata[] = [];

  // Process each schema file
  for (const schemaFile of schemaFiles) {
    const fullPath = path.join(schemasDir, schemaFile);
    const rawContent = JSON.parse(fs.readFileSync(fullPath, 'utf-8'));

    // Extract version from filename: v1.schema.json -> 1
    const versionMatch = schemaFile.match(/v(\d+)\.schema\.json$/);
    const version = versionMatch ? parseInt(versionMatch[1]) : 1;

    // Get schema path: common/boilerplate/v1.schema.json -> common/boilerplate
    const schemaPath = path.dirname(schemaFile).replace(/\\/g, '/');

    // Determine category: first folder after schemas/
    const category = schemaPath.split('/')[0];

    // Construct schema ID
    const schemaId = rawContent.$id || `https://mapcolonies.com/${schemaPath}/v${version}`;

    // Extract references
    const refs = { external: [], internal: [] };
    extractReferences(rawContent, refs);

    // Try to find corresponding TypeScript file
    let typeContent = '';
    const tsPath = path.join(buildDir, schemaPath, `v${version}.schema.d.ts`);
    if (fs.existsSync(tsPath)) {
      typeContent = fs.readFileSync(tsPath, 'utf-8');
    }

    // Check for config file
    const configPath = path.join(schemasDir, schemaPath, `v${version}.configs.json`);
    const hasConfig = fs.existsSync(configPath);

    schemas.push({
      id: schemaId,
      path: schemaPath,
      version,
      title: rawContent.title || `Schema v${version}`,
      description: rawContent.description || '',
      category,
      rawContent,
      typeContent,
      references: [...new Set(refs.external)], // Remove duplicates
      internalRefs: [...new Set(refs.internal)],
      hasConfig,
      referencedBy: [], // Will be populated next
    });
  }

  // Calculate reverse dependencies
  for (const schema of schemas) {
    for (const otherSchema of schemas) {
      if (otherSchema.references.includes(schema.id)) {
        schema.referencedBy.push(otherSchema.id);
      }
    }
  }

  // Calculate category counts
  const categoryMap = new Map<string, number>();
  for (const schema of schemas) {
    categoryMap.set(schema.category, (categoryMap.get(schema.category) || 0) + 1);
  }

  const categories = Array.from(categoryMap.entries())
    .map(([name, count]) => ({ name, count }))
    .sort((a, b) => a.name.localeCompare(b.name));

  // Write output
  const data: SchemaData = { schemas, categories };
  const outputPath = path.join(outputDir, 'schemas.json');
  fs.writeFileSync(outputPath, JSON.stringify(data, null, 2));

  console.log(`✅ Schema data written to ${outputPath}`);
  console.log(`   - Total schemas: ${schemas.length}`);
  console.log(`   - Categories: ${categories.length}`);
};

// Run the script
buildSchemaData().catch((error) => {
  console.error('❌ Error building schema data:', error);
  process.exit(1);
});
